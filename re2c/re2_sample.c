/* Generated by re2c 0.13.5 on Fri May 31 11:25:53 2013 */
#line 1 "re2_sample.re2c"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
 
/* CAUTION: FOR BREVITY PURPOSES, THIS PROGRAM DOES NOT HAVE COMPLETE ERROR HANDLING */
 
/* these are the tokens: language constructs and keywords are represented as numbers */
#define VAR 1
#define VARIABLE 2
#define EQUAL 3
#define STRING 4
#define END_TOKEN 5
#define YYCTYPE char
 
/**
 * this structure will hold pointers to beginning and end of the token string; the "lexeme"
 * these pointers just point into the input buffer; they should not be freed.
 */
typedef struct lexeme_struct {
  char *start;
  char *current;
} lexeme_t;
 
/**
 * this function will advance the lexeme start to the start of the next token; will advance current  to the
 * end of the next token; and will return the token number that was encountered.
 * The function will return END_TOKEN when the end of the string has been reached.
 * Ideally, lexeme  start and current pointers should not be moved back by the caller while tokens are being read.
 */
int next_token(char *text, int textLength, lexeme_t* lexeme) {
  if (lexeme->current >= (text + textLength)) {
    return END_TOKEN;
  }
  lexeme->start = lexeme->current;
 

#line 40 "re2_sample.c"
	{
		YYCTYPE yych;

		yych = *lexeme->current;
		switch (yych) {
		case '\t':
		case '\v':
		case '\f':
		case ' ':	goto yy8;
		case '"':	goto yy7;
		case '$':	goto yy4;
		case '=':	goto yy5;
		case 'v':	goto yy3;
		default:	goto yy2;
		}
yy2:
yy3:
		yych = *++lexeme->current;
		switch (yych) {
		case 'a':	goto yy17;
		default:	goto yy2;
		}
yy4:
		yych = *++lexeme->current;
		switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z':	goto yy14;
		default:	goto yy2;
		}
yy5:
		++lexeme->current;
#line 46 "re2_sample.re2c"
		{ return EQUAL; }
#line 134 "re2_sample.c"
yy7:
		yych = *++lexeme->current;
		switch (yych) {
		case '"':	goto yy2;
		default:	goto yy10;
		}
yy8:
		++lexeme->current;
#line 51 "re2_sample.re2c"
		{ lexeme->current++; }
#line 145 "re2_sample.c"
yy10:
		++lexeme->current;
		yych = *lexeme->current;
		switch (yych) {
		case '"':	goto yy12;
		default:	goto yy10;
		}
yy12:
		++lexeme->current;
#line 50 "re2_sample.re2c"
		{ return STRING; }
#line 157 "re2_sample.c"
yy14:
		++lexeme->current;
		yych = *lexeme->current;
		switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z':	goto yy14;
		default:	goto yy16;
		}
yy16:
#line 45 "re2_sample.re2c"
		{ return VARIABLE; }
#line 229 "re2_sample.c"
yy17:
		yych = *++lexeme->current;
		switch (yych) {
		case 'r':	goto yy18;
		default:	goto yy2;
		}
yy18:
		++lexeme->current;
#line 44 "re2_sample.re2c"
		{ return VAR; }
#line 240 "re2_sample.c"
	}
#line 52 "re2_sample.re2c"

}
 
int main() {
  char *input = "var $name = \"My name is John\";";
  int len = strlen(input);
  int token = 0;
  char *lexemeString = NULL;
  lexeme_t lexeme;
  lexeme.start = input;
  lexeme.current = input;
 
  /* start going through the tokens */
  while (token = next_token(input, len, &lexeme)) {
    switch (token) {
    case VAR:
      printf("Found VAR keyword at position %d\n", (int)(lexeme.start - input));
      break;
    case EQUAL:
      printf("Found EQUAL sign at position %d\n", (int)(lexeme.start - input));
      break;
    case VARIABLE:
      printf("Found variable at position %d. ", (int)(lexeme.start - input));
 
      /* output the variable string by creating a new string from the lexeme's start and current pointer */
      lexemeString = malloc(lexeme.current - lexeme.start + 1 + 1);
      strncpy(lexemeString, lexeme.start, lexeme.current - lexeme.start + 1);
      lexemeString[lexeme.current - lexeme.start + 1] = '\0';
      printf("variable:%s\n", lexemeString);
      free(lexemeString);
      break;
    case STRING:
      printf("Found string at position %d. ", (int)(lexeme.start - input));
 
      /* output the variable string by creating a new string from the lexeme's start and current pointer */
      lexemeString = malloc(lexeme.current - lexeme.start + 1 + 1);
      strncpy(lexemeString, lexeme.start, lexeme.current - lexeme.start + 1);
      lexemeString[lexeme.current - lexeme.start + 1] = '\0';
      printf("string:%s\n", lexemeString);
      free(lexemeString);
      break;
    default:
      break;
    }
    if (END_TOKEN == token) {
      break;
    }
    lexeme.current++;
  }
}
